% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stanoptimis.R
\name{stanoptimis}
\alias{stanoptimis}
\title{Optimize / importance sample a stan model.}
\usage{
stanoptimis(standata, sm, init = 0, verbose = FALSE, adjtransform = TRUE,
  deoptim = FALSE, decontrol = list(), isloops = 5, isloopsize = 500,
  issamples = 500, cores = 1)
}
\arguments{
\item{standata}{list object conforming to rstan data standards.}

\item{sm}{compiled stan model object.}

\item{init}{init argument conforming to rstan init standards.}

\item{verbose}{Logical. Extra output while fitting?}

\item{adjtransform}{Logical. If TRUE, the MAP estimate used as the basis for sampling will be based on the *unconstrained*
parameters. If FALSE, it will use the estimate for *constrained* parameters.}

\item{deoptim}{Do first pass optimization using differential evolution? Slower, but better for cases with multiple
minima / difficult optimization.}

\item{decontrol}{List of control parameters for differential evolution step, to pass to \code{\link[DEoptim]{DEoptim.control}}.}

\item{isloops}{Number of iterations of adaptive importance sampling to perform after optimization.}

\item{isloopsize}{Number of samples per iteration of importance sampling.}

\item{issamples}{Number of samples to use for final results of importance sampling.}

\item{cores}{Number of cpu cores to use.}
}
\value{
list containing: optimfit, the result from optimizing with stans optimizer;
stanfit, the stanfit object used;
posterior, the sampled posterior;
transformedpars, the full model output based on the posterior;
transformedpars_old, a simple summary approach based on the minimum and Hessian;
isdiags, a list containing elements used by \code{\link{isdiag}} for importance sampling diagnostics.
}
\description{
Optimize / importance sample a stan model.
}
\examples{
#' \dontrun{
library(rstan)
scode <- "
parameters {
  real y[2];
}
model {
  y[1] ~ normal(0, 1);
  y[2] ~ double_exponential(0, 2);
}
"

sm <- stan_model(model_code=scode)
fit <- sampling(sm, iter = 10000)
summary(fit)$summary

## extract samples as a list of arrays
e <- extract(fit, permuted = TRUE)

optimis <- stanoptimis(standata = list(),sm = sm,isloops=10,issamples = 1000,cores=3)


apply(optimis$rawposterior,2,mean)
apply(optimis$rawposterior,2,sd)
isdiag(optimis)

plot(density(optimis$rawposterior))
points(density(e2$y))
}
}
